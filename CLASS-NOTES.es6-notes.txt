

................
MISC TIPS!
................

in console:
console.table(myobject)

document.querySelector('.classname')
>> one of many things I'm seeing fly by that "explain" or whatever, why folks are all like, "no one cares about jQuery anymore" -- helps me see how that's become the general vibe in javascript/frontend-land

apparently can use ${myvariable} to output my variable in the middle of a string?
>> maybe only in `` backticked strings...

tax = tax || 0.13;
^^ tax will equal itself if it's been assigned a value, 

omg COOL!!!!!
<img src="https://unsplash.it/100/100?random" />

"what is an iterable?" -- most things, apparently... not just arrays/objects -- strings, blahblah -- he sorta explains it at the start of video #28

"prototypes" -- six, plus a new one in es6: "symbol"
>> string, array, object, , , undefined (apparently is a prototype!)

Symbols, as Stacy said, kinda a warped way to create a unique identifyer 

console - "proto" - he showed how to see what methods etc. are available to the class/whatever you're looking at -- like, all the methods available to the class we created...

import blahblah from './pathtofile/myfile'
>> don't include ".js"
>> P.S. if you want to be able to "import" something, you have to have said "this can be exported" in the source file/function (i.e. "export class MyClass "..... --> "MyClass" will be importable)

"forEach()" method (NOT a foreach loop like php) -- executes a provided function once for each array element

would love to understand bind().......

The following are the same -- first one is "old way," second is "es6":
const page = this.props.page
const {page} = this.props


................
END MISC TIPS!
................


"var variables are function-scoped" but if you aren't in a function, they're "global"-ish

p.s. generally want to keep your variables inside your function -- if you need it outside your function, you can return the value from the function and store that "return" as a variable

"let and const variables are scoped to the block" i.e. if you declare it inside the curly braces "if", it only exists inside those curly braces, aka, in the block...


"const" variables *cannot* be updated!!
>> but if a const variable is, say, an object, you *can* update attributes of that variable


var-let-const:
"use const by default"
"only use "let" if rebinding is needed
("var" souldn't be used in es6)

var-let-const:
"use "var" for top-level variables that are shared across many (especially larger) scopes"
"use "let" for localized variables in smaller scopes"
"refactor "let" to "const" only after some code has been written and you're reasonably sure htat you've got a case where there shoulnd't be variable reassignment"

.........
arrow functions:
"fat arrow" instead of"..... (see example)

Phis says: arrow functions are also about that scope stuff
>> P.S. apparently Tone has banned arrow functions in cwd_itc / cwd_project :D (via eslint)

// old way class definitions
var Whatever = function() {
  // stuff
  this.val = 1;
  this.render = function() {
    return "some value";
  }
  this.myFunction = () => {
    this.val()
    // stuff
  };
}
var w = new Whatever();

.........
"template tag" =
${stuff}

tagged-templates (video 14)
>> something he said while he had "debugger;" inside highlight() -- the "strings" array is always 1 more than the "values" array, b/c it includes a string value for before-and-after every "value"/variable inside that string -- so even if your template string (``) ends with a template tag/variable (${thing}), there "strings" array (in highlight()) will get one more array item at the end with a value of "" .........(alles klar?)


.........
string improvements via string methods in es6, such as:
.includes()
>> "was going to be "contains()" but there were conflicts with Blahblah so it ended up being includes()"

For "fun", check out the "repeat" example at the end of "17", re: Batman


.........
destructuring and functions (video 21 + destructuring-and-functions.html)
>> also re: setting default argument values for your functions, AND, sending "named arguments" when you call the function (instead of relying on the argument order):
>>>> TL;DR: if you're going to have a ":" in your arguments (in the function definition or when you call the function), you'll need to use ({}), not just ()
>>>> in other words, if you're setting default argument values for your function OR sending "named arguments" when you use the function, you're going to have to add {} inside your function's "arguments parenthetical" (), i.e.
tipCalc({ tip: 0.20, total: 200 })

.........
"for-of-examples" (whichever video) -- like halfway thru or whatever, he's talking about how you "don't have to convert to a true array, you can use for...of to iterate through things"

.........
"an array of improvements" (module 07)

Array-from-and-of.html
>> (Hugh) So the Array.a_method_in_this_section_like_from() thing takes something that's Array-ish and (kinda)extracts the parts that can be treated as an array / have array things done to them...

.........
(module 08)
when they say "rest params" they're talking about "...the rest" use of the word "rest"


........
(promises)
"i don't want to stop javascript from running, the data will come and i'll use it when it gets here, but if ....
just want to start this thing, and when it comes back, i'll deal with the result"


........
(module 14)
systemjs -- get more package things and whatever, wihtout having to install everything from node...
https://github.com/systemjs/systemjs
npm install systemjs

"babel is a JavaScript compiler" -- you put javascript in, you get ES5-friendly javascript out, so, protects against any ES6 incompatability issues
live demo/fiddle tool:
https://babeljs.io/repl

"polyfill" -- if the browser does not have "it" (whatever thing), we'll add the JavaScript for "it"
>> Example for Array.from():
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Polyfill
EVEN BETTER! You can use Polyfill.io, and then, Polyfill.io's magic adds whatever Polyfill is needed for the browser in question, in order to use your script.  For example:
<script crossorigin="anonymous" src="https://polyfill.io/v3/polyfill.min.js"></script>



........
(module 17, proxies)
proxies let you overwrite the default behaviors of objects' operations / of an operation on an object
>> when you want to overwrite a default operation, those things are called "traps" -- a trap sits in the middle, implement my own logic / interrupt

........
(module 18, lets)
"sets" in JS is like a unique array in that you can only ever add an item once...
"a list of items, which we  ... [??] "
>> sorta like an associative array, where the keys and the values are identical

........
(module 19, maps)
"sets are to arrays" "maps are to objects"
>> similar to sets, but they have keys and values instead of just values
>> "use maps when you want to store/use data about the object instead of storing data ON/IN the object"
>> weak maps doesn't have a size and you can't iterate over it (just like weak sets, supposedly)


........
when you do something synchronously, you wait for a task to be done before moving on; if you do it asynchronously, the script keeps going while things are in-progress / while a task is running
>> if you wait on a task to finish, they call it "blocking"

"high order function" -- used an example from his class about Node -- something about having a function factory type thingy, 
>> think about how a funciton like .map() takes a function as an argument -- like this:
myarray.map(function => {
});
>> soooo... high order functions, erm, have something to do with that...

we can't for...of on an Object, but we can for...of on Object.entries()
>> Note: in the following, "inventory" is a variable containing Object.entries
Object.entries(inventory)


........
listening to Phil about cwd_events, etc.
........

what he calls a "service" (his words) = the thing to request the data

re: "import" -- this is the new es6 way of importing/requiring -- "in the old days" you'd use "require" -- "import" came from node, which has been using "import" for ages

webpack.mix.js = compiler thing, creates cwd_events.js, cwd_events.css, things like that

app.js > lines 15-31 > typical stuff you'll see in any drupal module / js drupal module thing:
https://github.com/CU-CommunityApps/CD_cwd_events/blob/master/src/app/js/app.js

https://github.com/CU-CommunityApps/CD_cwd_events/blob/master/src/Plugin/Block/EventsBlock.php#L54
>> add drupalSettings array to cwd_events library stuff

"localist-viewer" is a wrapper for "react-localist-viewer", to make it simpler/easier/lower level-of-entry to integrate with the react app

"javascript has loose typing" -- you can have a variable that's an integer and later change it to a string, etc. -- can become problematic/messy/unreliable/etc.
>> in react (react-localist-viewer > src > lib > localist.jsx), you create variables with PropType
>>>> localist.jsx around line 19, has an instance of super() 
>>>> Phil says: "you only have to use super() if you're extending a class" -- when you have to reference the initial class of variables -- "whatever components this takes, I want those same things from the thing I'm inheriting / extending" -- "pass these properties to the constructor of my parent" -- "i also want to reference my parent constructor"
>> "see also" type-scripting (or don't -- just know that that's what type-scripting is about)
>> Phil said he installs a node module called "type" and that node module helps him make sure that types line up and whatnot

"async" and "await" examples in localist.jsx, starting around line 175
>> p.s. Phil says: before es6, everything in JS was asynchronous (by default), and ppl used callbacks + nested callbacks to make things wait to be processed until fetches come back
>> "if you have an async and an await, the await means, don't process the rest of this til this is done"
>> for example, "this.setState({})" in localist.jsx would be in a callback / nested callback

(misc fyi)
"const" >> a const variable can't have its type changed (!)

this.setState() -- the setting of "page" in this funtion, changes the value of "page" to the current page (i think)

In this example, the ones without {} have default exports -- not all of them do (like if you go to the source files, you'll see a line that looks lke "export default myThingThing):
import React from 'react';
import { render } from "react-dom";
import { LocalistComponent } from "./lib";

Phil says he never uses var -- only exception is if he's not running it through a transpiler

$('#id').each(function() {
  // stuff
});
>> typical jquery situation
>> totally dependent on the dom -- difficult for testing -- and modern javascript they're trying to get away from being so reliant on the dom





